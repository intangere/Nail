##########################
#        Nail Lang       #
#  Reactive Programming  #
#       By Photonic      #
##########################
import strutils
import tables
import macros
import math
randomize()
proc nrandom(): string = 
  var result_var = ""
  var f = open("/dev/urandom")
  var r: int32
  discard f.readBuffer(addr r, 4)
  close(f)
  if r < 0:
    r = -r
  for value in intToStr(r):
    case value:
      of '1': result_var.add("a")
      of '2': result_var.add("b")
      of '3': result_var.add("c")
      of '4': result_var.add("d")
      of '5': result_var.add("e")
      of '6': result_var.add("f")
      of '7': result_var.add("g")
      of '8': result_var.add("h")
      of '9': result_var.add("i")
      of '0': result_var.add("j")
      else: discard value
  return result_var

#Declare the variables
var Container = initTable[string, string]()
var Dependencies = initTable[string, seq[string]]()
var AST: seq[seq[string]] = @[]
var order = ["BIND", "DEPENDS", "DIV", "MUL", "ADD", "SUB", "EQUAL", "ECHO"]
var operators = ["EQUAL", "BIND", "DEPENDS", "DIV", "MUL", "ADD", "SUB", "ECHO"]
var AST_NODES = initTable[string, seq[string]]()
var text_section: seq[string] = @[]
var data_section: seq[string] = @[]
var global_section: seq[string] = @[]
var start: seq[string] = @[]
var bss_section: seq[string] = @[]
var asm_variables: seq[string] = @[]
text_section.add("section .text")
text_section.add("  global _start")
data_section.add("section .data")
bss_section.add("section .bss")
start.add("_start:")

var asm_declaration = initTable[string, bool]()
asm_declaration["sprint"] = false
asm_declaration["quit"] = false
asm_declaration["iprint"] = false
asm_declaration["iprintln"] = false

var asm_functions: seq[string] = @[]

var asm_program: seq[string] = @[]
asm_program.add(";Generated by the Nail Compiler")

proc tokenize(program: string) = 
  var tokens = program.split(" ")
  var t = 0
  var AST_NODE: seq[string] = @[]
  for token in tokens:
      case token:
        of ":=" :
          add(AST_NODE, "DEPENDS")
          var deps = tokens
          var i = 0
          while i < len(deps):
            case deps[i]:
              of "+", "-", "*", "/", "=", " ", ":=": 
                deps.delete(i)
                i -= 1
            i += 1
          deps.delete(0)
          add(AST_NODE, deps)
          add(AST_NODE, "BIND")
          add(AST_NODE, "EQUAL")
        of "fn" : add(AST_NODE, "FUNC") #Parse from fn to RBRACE
        of "{" : add(AST_NODE, "LBRACE")
        of "}" : add(AST_NODE, "RBRACE")
        of "+" : add(AST_NODE, "ADD")
        of "-" : add(AST_NODE, "SUB")
        of "*" : add(AST_NODE, "MUL")
        of "/" : add(AST_NODE, "DIV")
        of "=" : add(AST_NODE, "EQUAL")
        of "echo" : add(AST_NODE, "ECHO")
        of " " : discard
        else : add(AST_NODE, token)
      t += 1
  if len(AST_NODE) > 0:
    add(AST, AST_NODE)

proc genASM(op: string, expr1: string, expr2: string, result_var: string) = 
  if op == "add" or op == "sub":
    try: 
      start.add("  mov eax, $#" % [intToStr(parseInt(expr1))])
    except:
      start.add("  mov eax, [$#]" % expr1)

    try: 
      start.add("  mov ebx, $#" % [intToStr(parseInt(expr2))])
    except:
      start.add("  mov ebx, [$#]" % expr2)
    start.add("  $# eax, ebx" % [op])
    start.add("  mov [$#], eax" % [result_var])
    if bss_section.contains("  $# resb 255" % [result_var]):
      discard
    else:
      bss_section.add("  $# resb 255" % [result_var])
  if op == "mul" or op == "div":
    try: 
      start.add("  mov eax, $#" % [intToStr(parseInt(expr1))])
    except:
      #may have to add this line back in later on
      #start.add("  mov eax, [$#]" % expr1) 
      discard

    try: 
      start.add("  mov ebx, $#" % [intToStr(parseInt(expr2))])
    except:
      start.add("  mov ebx, [$#]" % expr2)
    start.add("  $# ebx" % [op])
    start.add("  mov [$#], eax" % [result_var])
    if bss_section.contains("  $# resb 255" % [result_var]):
      discard
    else:
      bss_section.add("  $# resb 255" % [result_var])
proc interpret*() = 
    var x = 0
    while x < len(AST):
      for value in order:
        var i = 0
        var node = AST[x]
        var result_var = nrandom()
        asm_variables.add(result_var)
        while i < len(node):
            var expr = node[i]
            if expr == value:
                if expr in operators:
                  var expr1 = ""
                  var expr2 = ""
                  try:
                    expr1 = node[i-1]
                  except IndexError:
                    discard
                  try:
                    expr2 = node[i+1]
                  except IndexError:
                    discard
                  if expr == "EQUAL":
                    for key, values in Dependencies: #WORK ON THIS!
                      var ast_node: seq[string] = @[]
                      if values.contains(node[i-1]):
                        add(ast_node, key)
                        add(ast_node, "EQUAL")
                        for expr in AST_NODES[key]:
                          add(ast_node, expr)
                        AST.insert(ast_node, x+1)
                    Container[node[i-1]] = expr2
                    node[i+1] = expr2

                    if expr2 in asm_variables:
                      start.add("  mov eax, [$#]" % [expr2])
                      start.add("  mov [$#], eax" % [expr1])
                      if ("  $# resb 255" % [expr1]) notin bss_section:
                        if node[i-1] notin asm_variables:
                          bss_section.add("  $# resb 255" % [expr1])
                    else:
                      if node[i-1] notin asm_variables:
                        add(data_section, "  $# dd $#" % [node[i-1], expr2.split(".")[0]])
                        asm_variables.add(node[i-1])
                      else:
                        start.add("  mov eax, $#" % [expr2])
                        start.add("  mov [$#], eax" % [expr1])
                    system.delete(node, i+1)
                    system.delete(node, i)
                    system.delete(node, i-1)             
                    i -= 1
                  if expr == "DIV":
                    node[i] = result_var
                    genASM("div", expr1, expr2, result_var) #Add if mul or div to the genASM
                    system.delete(node, i+1)
                    system.delete(node, i-1)         
                    i -= 2
                  if expr == "MUL":
                    node[i] = result_var
                    genASM("mul", expr1, expr2, result_var) #Add if mul or div to the genASM
                    system.delete(node, i+1)
                    system.delete(node, i-1)                          
                    i -= 2
                  if expr == "ADD": #Turn this into a function that automatically changes the operatation
                    #That way I can call genASM("add", expr1, expr2 ); genASM("sub", expr1, expr2); etc
                    node[i] = result_var
                    genASM("add", expr1, expr2, result_var)
                    system.delete(node, i+1)
                    system.delete(node, i-1)
                    i -= 2
                  if expr == "SUB":
                    node[i] = result_var
                    genASM("sub", expr1, expr2, result_var)
                    system.delete(node, i+1)
                    system.delete(node, i-1)       
                    i -= 2
                  if expr == "DEPENDS":
                    var c = i
                    system.delete(node, c)
                    while node[c] != "BIND":
                      var dep = node[c]
                      if Dependencies.haskey(expr1):
                        if not Dependencies[expr1].contains(dep):
                          Dependencies.mget(expr1).add(dep)
                      else:
                        Dependencies[expr1] = @[]
                        Dependencies.mget(expr1).add(dep)
                      system.delete(node, c)
                    system.delete(node, c)
                  if expr == "BIND":
                    var b = i+2
                    while b < len(node):
                      if AST_NODES.has_key(node[0]):
                        AST_NODES.mget(node[0]).add(node[b])
                      else:
                        AST_NODES[node[0]] = @[]
                        AST_NODES.mget(node[0]).add(node[b])
                      b+=1  
                  if expr == "ECHO":
                    try: 
                      start.add("  mov eax, $#" % [intToStr(parseInt(node[i+1]))])
                    except:
                      start.add("  mov eax, [$#]" % node[i+1])
                    start.add("  call iprintln")
                    system.delete(node, i+1)
                    system.delete(node, i)
                  AST[x] = node
            i = i + 1
      if len(AST[x]) == 0:
        system.delete(AST, x)
     # echo "REAL",AST
    start.add("  call quit")
    asm_functions.add("quit:")
    asm_functions.add("  mov ebx, 0")
    asm_functions.add("  mov eax, 1")
    asm_functions.add("  int 80h")
    asm_functions.add("  ret")
proc Reactive(r: string, value: string) = 
  if Container.hasKey(r):
    Container.mget(r).add(r)
  else:
    Container[r] = ""
    Container.mget(r).add(r)

when isMainModule:
  import os
  let program = if paramCount() > 0: readFile paramStr(1)
    else: readAll stdin
  for line in program.split("\n"):
    tokenize line
  echo AST
  interpret()
  for value in text_section:
    asm_program.add(value)
  for value in bss_section:
    asm_program.add(value)
  for value in data_section:
    asm_program.add(value)
  for value in global_section:
    asm_program.add(value)
  for value in start:
    asm_program.add(value)
  for value in asm_program:
    if "iprintln" in value:
      if asm_declaration["iprintln"] == false:
        asm_declaration["iprintln"] = true
        asm_functions.add("iprintln:")
        asm_functions.add("  call iprint")
        asm_functions.add("  push eax")
        asm_functions.add("  mov eax, 0Ah")
        asm_functions.add("  push eax")
        asm_functions.add("  mov eax, esp")
        asm_functions.add("  call sprint")
        asm_functions.add("  pop eax")
        asm_functions.add("  pop eax")
        asm_functions.add("  ret")
        asm_functions.add("iprint:")
        asm_functions.add("  push eax")
        asm_functions.add("  push ecx")
        asm_functions.add("  push edx")
        asm_functions.add("  push esi")
        asm_functions.add("  mov ecx, 0")
        asm_functions.add("asciiLoop:")
        asm_functions.add("  inc ecx")
        asm_functions.add("  mov edx, 0")
        asm_functions.add("  mov esi, 10")
        asm_functions.add("  idiv esi")
        asm_functions.add("  add edx, 48")
        asm_functions.add("  push edx")
        asm_functions.add("  cmp eax, 0")
        asm_functions.add("  jnz asciiLoop")
        asm_functions.add("printLoop:")
        asm_functions.add("  dec ecx")
        asm_functions.add("  mov eax, esp")
        asm_functions.add("  call sprint")
        asm_functions.add("  pop eax")
        asm_functions.add("  cmp ecx, 0")
        asm_functions.add("  jnz printLoop")
        asm_functions.add("  pop esi")
        asm_functions.add("  pop edx")
        asm_functions.add("  pop ecx")
        asm_functions.add("  pop eax")
        asm_functions.add("  ret")
        asm_functions.add("slen:")
        asm_functions.add("  push    ebx")
        asm_functions.add("  mov     ebx, eax")
        asm_functions.add("nextchar:")
        asm_functions.add("  cmp     byte [eax], 0")
        asm_functions.add("  jz      finished")
        asm_functions.add("  inc     eax")
        asm_functions.add("  jmp     nextchar")
        asm_functions.add("finished:")
        asm_functions.add("  sub     eax, ebx")
        asm_functions.add("  pop     ebx")
        asm_functions.add("  ret")
        asm_functions.add("sprint:")
        asm_functions.add("  push edx")
        asm_functions.add("  push ecx")
        asm_functions.add("  push ebx")
        asm_functions.add("  push eax")
        asm_functions.add("  call slen")
        asm_functions.add("  mov edx, eax")
        asm_functions.add("  pop eax ")
        asm_functions.add("  mov ecx, eax")
        asm_functions.add("  mov ebx, 1")
        asm_functions.add("  mov eax, 4")
        asm_functions.add("  int 80h")
        asm_functions.add("  pop ebx")
        asm_functions.add("  pop ecx")
        asm_functions.add("  pop edx")
        asm_functions.add("  ret")

  for value in asm_functions:
    asm_program.add(value)
  for value in asm_program:
    echo value
#type 
#    R = ref object of Reactive
#      name*: self
#      value*: string